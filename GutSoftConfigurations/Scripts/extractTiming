#!/usr/bin/python

import sys, os, getopt, glob

def main(argv) :
    """
    
    extractTimingFromCMSSW
    
    activate timing service in CMSSW and use this python script tp average timing per module

    required parameters
    --logfile <names>                         :       logfile names, single name or wildcard expression in \"

    optional parameters                       :
    --help (-h)                               :       help
    --debug (-d)                              :       debug statements
    
    """

    # default
    logfilename = ''
    debug = 0

    try:
        opts, args = getopt.getopt(argv, "", ["help", "debug", "logfile="])
    except getopt.GetoptError:
        print main.__doc__
        sys.exit(2)

    # check command line parameter
    for opt, arg in opts :
        if opt == "--help" :
            print main.__doc__
            sys.exit()
        elif opt == "--debug" :
            debug = 1
        elif opt == "--logfile" :
            logfilename = arg

    if logfilename == '' :
        print main.__doc__
        sys.exit(2)
        
    # instantiate dictionaries and counters
    timeEvent       = 0
    timeEventCount  = 0
    timeModuleDict  = {}
    timeModuleCount = {}


    for filename in glob.glob(logfilename) :
        try:
            logfile = open(filename)
        except IOError:
            print ''
            print 'Could not open logfile: ',logfilename
            print main.__doc__
            sys.exit(2)

        line = logfile.readline()
        time = {}
        while line :
            line = line.strip()
            # timevent is always the last information from the event
            # fill arrays when timevent is found, normalize with normalization info
            if line.count('TimeModule>') > 0 :
                if debug :
                    print 'TimeModule line:',line
                try:
                    linearray = line.split()
                    if len(linearray) == 6 :
                        module = linearray[-3]
                        time[module] = float(linearray[-1])
                        if module in timeModuleCount.keys() :
                            timeModuleCount[module] += 1
                        else :
                            timeModuleCount[module] = 1
                except ValueError:
                    print 'line:',line,'could not be used to extract time of a module'
            if line.count('TimeEvent>') > 0 :
                if debug :
                    print 'TimeEvent line:',line
                linearray = line.split()
                try:
                    timeEvent      += float(linearray[-1])
                    timeEventCount += 1
                    for module in time.keys() :
                        if module in timeModuleDict.keys() :
                            timeModuleDict[module] += time[module]/time['gutSoftTimingNormalizationAnalyzer']
                        else :
                            timeModuleDict[module] = time[module]/time['gutSoftTimingNormalizationAnalyzer']
                except ValueError:
                    print 'line:',line,'could not be used to extract time of the event'
            line = logfile.readline()

    # special module lists
    rsmodules = ['roadSearchSeeds','rawRoadSearchClouds','rsTrackCandidates','rsWithMaterialTracks']
    ckfmodules = ['globalMixedSeeds','ckfTrackCandidates','ctfWithMaterialTracks']

    trackmodules = rsmodules + ckfmodules

    # print summary

    separator = ''
    for i in range(94) :
        separator += '-'

    print ''
    print 'Module Timing Summary'
    print ''
    print separator

    for module in rsmodules :
        print 'module: %50s time/ev: %9.5f percentage: %4.1f' % (module, timeModuleDict[module]/timeModuleCount[module], (timeModuleDict[module]/timeModuleCount[module])/(timeEvent/timeEventCount)*100)

    print separator

    for module in ckfmodules :
        print 'module: %50s time/ev: %9.5f percentage: %4.1f' % (module, timeModuleDict[module]/timeModuleCount[module], (timeModuleDict[module]/timeModuleCount[module])/(timeEvent/timeEventCount)*100)

    print separator

    sorted_keys = timeModuleDict.keys()
    sorted_keys.sort()
    for module in sorted_keys :
        if module not in trackmodules :
            print 'module: %50s time/ev: %9.5f percentage: %4.1f' % (module, timeModuleDict[module]/timeModuleCount[module], (timeModuleDict[module]/timeModuleCount[module])/(timeEvent/timeEventCount)*100)

    print separator

    print 'events: %50d time/ev: %9.5f' % (timeEventCount, timeEvent/timeEventCount)

    # calculate time per event for RS and Ckf
    rsTimePerEvent = 0.
    for rsmodule in rsmodules :
        if rsmodule in timeModuleDict.keys() :
            rsTimePerEvent += timeModuleDict[rsmodule]/timeModuleCount[rsmodule]

    ckfTimePerEvent = 0.
    for ckfmodule in ckfmodules :
        if ckfmodule in timeModuleDict.keys() :
            ckfTimePerEvent += timeModuleDict[ckfmodule]/timeModuleCount[ckfmodule]

    print ''
    if  rsTimePerEvent != 0 :
        print 'module: %50s time/ev: %9.5f percentage: %4.1f' % ('RS', rsTimePerEvent, rsTimePerEvent/(timeEvent/timeEventCount)*100)
    if  ckfTimePerEvent != 0 :
        print 'module: %50s time/ev: %9.5f percentage: %4.1f' % ('CKF', ckfTimePerEvent, ckfTimePerEvent/(timeEvent/timeEventCount)*100)

    print ''
    print 'Summary Sheet output'
    print ''
    print 'format:'
    print ''
    print 'events'
    for module in rsmodules :
        print module
    for module in ckfmodules :
        print module

    print ''
    print timeEventCount

    for module in rsmodules :
        print timeModuleDict[module]/timeModuleCount[module]
    print rsTimePerEvent
    for module in ckfmodules :
        print timeModuleDict[module]/timeModuleCount[module]
    print ckfTimePerEvent
    
if __name__ == '__main__' :
    main(sys.argv[1:])
