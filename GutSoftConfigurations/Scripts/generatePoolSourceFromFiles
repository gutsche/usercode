#!/usr/bin/env python2.4

import sys, os, getopt, glob, popen2

def makeNonBlocking(fd):
    fl = fcntl.fcntl(fd, fcntl.F_GETFL)
    try:
        fcntl.fcntl(fd, fcntl.F_SETFL, fl | os.O_NDELAY)
    except AttributeError:
	    fcntl.fcntl(fd, fcntl.F_SETFL, fl | os.FNDELAY)

def main(argv) :
    """
    
    generatePoolSourceFromFiles
    
    take a file or a wildcard expression in \"\" and generate PoolSource
    execute in directory of files

    required parameters
    --file <names>                         :       file names (single file or wildcard expression in \"

    optional parameters                    :
    --dcache                               :       file is located in /pnfs/..., use dcache:
    --absolute                             :       use absolute paths
    --help (-h)                            :       help
    --debug (-d)                           :       debug statements
    
    """

    # default
    filename = ''
    absolute = 0
    debug = 0
    dcache = 0

    try:
        opts, args = getopt.getopt(argv, "", ["help", "debug", "file=", "absolute", "dcache"])
    except getopt.GetoptError:
        print main.__doc__
        sys.exit(2)

    # check command line parameter
    for opt, arg in opts :
        if opt == "--help" :
            print main.__doc__
            sys.exit()
        elif opt == "--debug" :
            debug = 1
        elif opt == "--absolute" :
            absolute = 1
        elif opt == "--dcache" :
            dcache = 1
        elif opt == "--file" :
            filename = arg

    if filename == '' :
        print main.__doc__
        sys.exit(2)


    absolute_dir = ''
    if absolute :
        absolute_dir = os.getcwd() + '/'
        
    filenames = glob.glob(filename)
    filenames.sort()

    filetype = 'file:'
    if dcache == 1 :
        filetype = 'dcache:'

    files = {}
    totalevents = 0
    corrupt_files = 0

    for filename in filenames :
	if filename.find('histograms') < 0 :
            # create tmp parameter-set
            (stdout,stdin) = popen2.popen4('/bin/mktemp')
            tempfilename = stdout.readline().strip()
            file = open(tempfilename,'w')
            #write check jdl
            file.write('process C = {\n')
            file.write('include "GutSoftConfigurations/MessageLogger/messageLogger.cff"\n')
            file.write('untracked PSet maxEvents = \n')
            file.write('{\n')
            file.write('  untracked int32 input = -1\n')
            file.write('}\n')
            file.write('source = PoolSource\n')
            file.write('{\n')
            file.write('  untracked vstring fileNames =\n')
            file.write('  {\n')
            file.write('    "'+filetype+absolute_dir+filename+'"\n')
            file.write('  }\n')
            file.write('}\n')
            file.write('# file check analyzer\n')
            file.write('include "GutSoftAnalyzers/GutSoftFileCheckAnalyzer/data/gutSoftFileCheckAnalyzer.cff"\n')
            file.write('path p =\n')
            file.write('{\n')
            file.write('  gutSoftFileCheckAnalyzer\n')
            file.write('}\n')
            file.write('}\n')
            file.close()
            # run parameter-set
            cmd = 'cmsRun ' + tempfilename
            proc = popen2.Popen4(cmd)
            #outfile = proc.fromchild
            #outfd = outfile.fileno()
            #makeNonBlocking(outfd)
            exit = proc.poll()
            lines = []
            while ( exit == -1 ) :
                lines += proc.fromchild.readlines()
                exit = proc.poll()
            if exit == 0 :
                events = 0
                try:
                    for line in lines:
                        if line.find('Number of Events:') >= 0:
                            events = int(line.split()[-1])
                except:
                    print 'Number of events could not be extracted from '+filetype+absolute_dir+filename
                files[filetype+absolute_dir+filename] = events
                totalevents += events
            else :
                corrupt_files = 1
                files[filetype+absolute_dir+filename] = -1
            os.remove(tempfilename)


    # output
    output = ''
    output += '#\n'
    output += '# '+ str(len(files)) + ' file(s) containing ' + str(totalevents) + ' events\n'
    output += '#\n'
    output += '# list of files (format: file events):\n'
    output += '#\n'
    for file in files.keys() :
        if files[file] != -1 :
            output += '# ' + file + ' ' + str(files[file]) + '\n'
    output += '#\n'
    if corrupt_files == 1 :
        output += '# list of corrupt files (format: file events):\n'
        output += '#\n'
        for file in files.keys() :
            if files[file] == -1 :
                output += '# ' + file + ' ' + str(files[file]) + '\n'
        output += '#\n'
    
    output += 'replace PoolSource.fileNames = {\n'
    for file in files.keys() :
        if files[file] != -1 :
            output += '  "' + file + '",\n'
    output = output[:-2]+'\n'
    output += '}\n'

    print output        

if __name__ == '__main__' :
    main(sys.argv[1:])
